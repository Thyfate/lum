#version 450 core

layout(set = 0, binding = 0, rgba32ui) uniform uimage2D  Gbuffer;
layout(set = 0, binding = 1, rgba8) uniform image2D raytraced_frame;
layout(set = 0, binding = 2, rgba8) uniform image2D  denoised_frame;

ivec2 size;
vec2 ratio;

vec2 load_old_uv(ivec2 pixel){
    vec2 old_uv = unpackUnorm2x16(imageLoad(Gbuffer, ivec2(pixel*ratio)).x);
    return old_uv;
}
vec3 decode(vec2 f){
    f = f * 2.0 - 1.0;
 
    vec3 n = vec3(f.x, f.y, 1.0 - abs(f.x) - abs(f.y));
    float t = clamp(-n.z, 0, 1);
    n.x += n.x > 0.0 ? -t : t;
    n.y += n.y > 0.0 ? -t : t;
    return normalize(n); //todo:
}
vec3 load_norm(ivec2 pixel){
    vec2 norm_encoded = unpackSnorm2x16(imageLoad(Gbuffer, ivec2(pixel*ratio)).y);
    return decode(norm_encoded);
}
int load_mat(ivec2 pixel){
    uint mat_encoded = imageLoad(Gbuffer, ivec2(pixel*ratio)).z;
    return int(mat_encoded);
}
float load_depth(ivec2 pixel){
    // ivec2 size = imageSize(Gbuffer);
    // if(any(greaterThanEqual(pixel, size)) || any(lessThan(pixel, ivec2(0)))) return 100000000000000.0;
    
    uint depth_encoded = imageLoad(Gbuffer, ivec2(pixel*ratio)).w;
    return uintBitsToFloat(depth_encoded);
}


//how bright pixel is
float luminance(vec3 color){
    vec3 luminance_const = vec3(0.2126, 0.7152, 0.0722);
    return dot(color, luminance_const);
}
float calculate_weight(
    vec3 color, vec3 color_center,
    vec3 normal, vec3 normal_center,
    int mat, int mat_center,
    float depth, float depth_center,
    ivec2 pix, ivec2 center_pix,
    float _phiDepth
){
    float weight;

    float phiNormal, phiDepth, phiIllum;
    phiNormal = 128.0;
    // phiDepth = _phiDepth;
    phiDepth = 0.0;
    phiIllum = 1;
    
          float weightPos = distance(vec2(pix), vec2(center_pix))*.5;
        // weightPos=0;
    const float weightNormal = pow(clamp(dot(normal_center, normal), 0, 1), phiNormal);
    const float weightZ = (phiDepth == 0) ? 0.0f : abs(depth_center - depth) / phiDepth;
    const float weightLillum = abs(luminance(color_center) - luminance(color)) / phiIllum;
    const float weigth_mat = (mat == mat_center) ? 1 : 0;

    weight = exp(0.0 - weightLillum - weightZ - weightPos) * weightNormal * weigth_mat;

    return weight;
}
//well, its time to implement denoiser. Spatial after temporal seems fine
vec3 denoise(ivec2 center_pix){
    ivec2 screenSize = size;

    float sum_weight = 0.0;
    vec3 sum_color = vec3(0);

     vec3 color_center = imageLoad(raytraced_frame, center_pix).rgb;
    float depth_center = load_depth(center_pix);
      int   mat_center = load_mat(center_pix);
     vec3  norm_center = load_norm(center_pix);

    const int radius = 4;
    for(int xx = -radius; xx <= radius; xx++){
    for(int yy = -radius; yy <= radius; yy++){
        ivec2 pix = center_pix + ivec2(xx,yy);
        const bool inside = all(greaterThanEqual(pix, ivec2(0))) && all(lessThan(pix, screenSize));
        const bool samePixel = (xx == 0 && yy == 0);
        if (inside){
             vec3 color = imageLoad(raytraced_frame, pix).rgb;
            float depth = load_depth(pix);
              int mat   = load_mat(pix);
             vec3 norm  = load_norm(pix);
            
            float phiDepth = max(depth, 1e-8) * 3.0;

            float weight = calculate_weight(
                color, color_center,
                norm, norm_center,
                mat, mat_center,
                depth, depth_center,
                pix, center_pix,
                phiDepth
            );

            sum_color += weight*color;
            sum_weight+= weight;
        }
    }}

    return sum_color / sum_weight;
}

layout(local_size_x = 8, local_size_y = 8) in;

void main(void){
    ivec2 pix = ivec2(gl_GlobalInvocationID.xy);
    size = imageSize(raytraced_frame);
    ratio = vec2(imageSize(Gbuffer))/vec2(size);
    
    vec3 color = denoise(pix);
    // vec3 color = imageLoad(raytraced_frame, pix).xyz;
    imageStore(denoised_frame, pix, vec4(color,1));
}
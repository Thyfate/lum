#version 450 core

//version with model to world

precision highp int;
precision highp float;

//TODO: move per-workgroup computations to different shader
//TODO: AND test shared perfomance
layout(push_constant) uniform constants{
    mat4 trans; //to map modelVoxels to game voxel world
    ivec3 model_size;
} PushConstants;

layout(set = 0, binding = 0, r8ui)  readonly uniform uimage3D modelVoxels;
//blocks and blockPalettes are copies 
layout(set = 0, binding = 1, r32i)           uniform iimage3D blocks;
layout(set = 0, binding = 2, r8ui) writeonly uniform uimage3D blockPalette;

ivec3 voxel_in_palette(ivec3 relative_voxel_pos, int block_id) {
    return relative_voxel_pos + ivec3(0,0,16*(block_id));
}
//TODO: balance, X>Y>Z for coherence
layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

//TODO: temp
// const ivec3 model_size = ivec3(16);
void main(void){
    //sqrt(1.5) is for more precise mapping so holes do not appear 
     vec3  relative_vox = vec3(gl_GlobalInvocationID.xyz) / vec3(10.0);
    //  vec3  relative_vox = gl_GlobalInvocationID.xyz / 2;
    //  vec3  relative_vox = gl_GlobalInvocationID.xyz;
    // if(
    //     (relative_vox.x < 0.8)
    //   ||(relative_vox.y < 0.8)
    //   ||(relative_vox.z < 0.8)
    //   ||(relative_vox.x > (float(PushConstants.model_size.x)-0.8)) 
    //   ||(relative_vox.y > (float(PushConstants.model_size.y)-0.8)) 
    //   ||(relative_vox.z > (float(PushConstants.model_size.z)-0.8)) //TODO float() on cpu
    // ) return;

    ivec3 irelative_vox   = ivec3(relative_vox);
    // ivec3 irelative_block = ivec3(relative_vox)/16;


    //part where actual transformation happens
    ivec3 itarget_vox = ivec3((PushConstants.trans * vec4(relative_vox,1)).xyz);
    ivec3 itarget_block = itarget_vox / 16;

    // vec3   target_block = ((PushConstants.trans * vec4(relative_vox,1)).xyz);
    // ivec3 itarget_block = ivec3(target_block);
    // ivec3 itarget_block = ivec3(target_block);
    //  vec3  target_vox = target_block*16.0;
    //  vec3  target_vox = target_block*16;
    // ivec3 itarget_vox = ivec3(target_vox);

    // ivec3 model_size = imageSize(modelVoxels);
    //+1 for propper rounding, so 15 results into 1
    // ivec3 model_size_in_blocks = (model_size + ivec3(1)) / 16;
    //if this is extra "out-of-bounds" voxel
    if (any(greaterThan(irelative_vox, PushConstants.model_size))) return;
    // if (any(   lessThan(irelative_vox, ivec3(0)))) return;

    //let it have X->Y->Z order for blocks in palette
    //so we have target voxel position, initial one and target block position in the world
    //what we have to do is find ID of final block in palette (that this voxel will belong to)
    //then we load voxel from its initial position
    //then we load it to target block in palette
    //then we set target block in world to block in palette ID
    //TODO: test different approaches to cast and dot etc...
    //WHERE IS MY IDOT
    // int target_block_in_palette = int(imageLoad(blocks, target_block).r);
    int target_block_in_palette = int(itarget_block.x + (itarget_block.y*5) + (itarget_block.z*5*5) + 3);
    // int target_block_in_palette = 2;

    //relative to palette block it will be written to
    // ivec3 target_palette_voxel = voxel_in_palette(itarget_vox.xyz % 16, target_block_in_palette);
    ivec3 target_palette_voxel = voxel_in_palette(itarget_vox.xyz % 16, target_block_in_palette);
    // int a=0;
    // if( irelative_vox.x == 0 ||
    //     irelative_vox.y == 0 ||
    //     irelative_vox.z == 0){
    //         a=1;
    //     }
    uvec4 voxel = imageLoad(modelVoxels, irelative_vox);
    if (voxel.r != 0){
        imageStore(blockPalette, target_palette_voxel, voxel); // maybe atomic?.. Could use temporal shared block for this
    }
}
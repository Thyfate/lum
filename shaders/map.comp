#version 450 core

precision highp int;
precision highp float;

//TODO: move per-workgroup computations to different shader
//TODO: AND test shared perfomance
layout(push_constant) uniform constants{
    mat4 trans; //to map modelVoxels to game voxel world
} PushConstants;

layout(set = 0, binding = 0, r8ui)  readonly uniform uimage3D modelVoxels;
//blocks and blockPalettes are copies 
layout(set = 0, binding = 1, r32i)           uniform iimage3D blocks;
layout(set = 0, binding = 2, r8ui) writeonly uniform uimage3D blockPalette;

ivec3 voxel_in_palette(ivec3 relative_voxel_pos, int block_id) {
    return relative_voxel_pos + ivec3(0,0,16*(block_id));
}
//TODO: balance, X>Y>Z for coherence
layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

//TODO: temp
ivec3 model_size = ivec3(16);
void main(void){
    //sqrt(1.5) is for more precise mapping so holes do not appear 
     vec3  relative_vox = gl_GlobalInvocationID.xyz / sqrt(1.5);
    //  vec3  relative_vox = gl_GlobalInvocationID.xyz / 2;
    //  vec3  relative_vox = gl_GlobalInvocationID.xyz;
    ivec3 irelative_vox = ivec3(relative_vox);

    if(
        irelative_vox.x < 1
      ||irelative_vox.y < 1
      ||irelative_vox.z < 1
      ||irelative_vox.x > 14
      ||irelative_vox.y > 14
      ||irelative_vox.z > 14
    ) return;

    //part where actual transformation happens
    ivec3   target_vox = ivec3((PushConstants.trans * vec4(relative_vox,1)).xyz);
    ivec3 target_block = (target_vox) / ivec3(16);

    // ivec3 model_size = imageSize(modelVoxels);
    //+1 for propper rounding, so 15 results into 1
    // ivec3 model_size_in_blocks = (model_size + ivec3(1)) / 16;
    //if this is extra "out-of-bounds" voxel
    if (any(greaterThanEqual(irelative_vox, model_size))) return;

    //let it have X->Y->Z order for blocks in palette
    //so we have target voxel position, initial one and target block position in the world
    //what we have to do is find ID of final block in palette (that this voxel will belong to)
    //then we load voxel from its initial position
    //then we load it to target block in palette
    //then we set target block in world to block in palette ID
    //TODO: test different approaches to cast and dot etc...
    //WHERE IS MY IDOT
    // int target_block_in_palette = int(imageLoad(blocks, target_block).r);
    int target_block_in_palette = int(target_block.x + (target_block.y*4) + (target_block.z*4*4) + 2);
    // int target_block_in_palette = 2;

    //relative to palette block it will be written to
    ivec3 target_palette_voxel = voxel_in_palette(target_vox.xyz % 16, target_block_in_palette);
    // int a=0;
    // if( irelative_vox.x == 0 ||
    //     irelative_vox.y == 0 ||
    //     irelative_vox.z == 0){
    //         a=1;
    //     }
    imageStore(blockPalette, target_palette_voxel,
            imageLoad(modelVoxels, irelative_vox)
            // ivec4(166*a)
            );
}